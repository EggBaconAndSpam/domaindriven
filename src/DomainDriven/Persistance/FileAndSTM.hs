module DomainDriven.Persistance.FileAndSTM where

import           DomainDriven.Internal.Class
import           RIO
import qualified RIO.ByteString                               as BS
import           System.Directory               ( doesFileExist )
import           Data.Char                      ( ord )
import           GHC.IO.Unsafe                  ( unsafePerformIO )
import           Data.Aeson
import qualified RIO.ByteString.Lazy                          as BL


data PersistanceError = EncodingError String
    deriving (Show, Eq, Typeable, Exception)

-- | Streaming json storage to disk with STM state.
data FileAndSTM model event = FileAndSTM
    { eventChan :: TChan (Stored event)
    , stateTVar :: TVar model
    , eventFile :: FilePath
    }
    deriving Generic

createFileAndStm
    :: (ToJSON event, FromJSON event)
    => FilePath
    -> (model -> Stored event -> model)
    -> model -- ^ initial model
    -> IO (FileAndSTM model event)
createFileAndStm fp appEvent m0 = do
    chan <- newTChanIO
    tvar <- newTVarIO m0
    f    <- do
        fileExists <- doesFileExist fp
        if fileExists then readFileBinary fp else pure ""
    let events = fmap eitherDecodeStrict . filter (not . BS.null) $ BS.splitWith
            (== fromIntegral (ord '\n'))
            f
    -- Read all existing events and apply to the model
    traverse_
        (either (throwM . EncodingError) (atomically . modifyTVar tvar . flip appEvent))
        events

    -- Create the thread that will persist events to file
    void . async . forever $ do
        s <- atomically $ readTChan chan
        let v = encode s <> BL.singleton (fromIntegral $ ord '\n')
        BL.appendFile fp v

    pure $ FileAndSTM chan tvar fp

instance FromJSON event => PersistanceHandler (FileAndSTM model event) model event where
    getModel (FileAndSTM _ tvar _) = readTVarIO tvar
    getEvents (FileAndSTM _ _ fp) = do
        f <- do
            fileExists <- doesFileExist fp
            if fileExists then readFileBinary fp else pure ""
        let events = fmap eitherDecodeStrict . filter (not . BS.null) $ BS.splitWith
                (== fromIntegral (ord '\n'))
                f
        traverse (either (throwM . EncodingError) pure) events

    transactionalUpdate (FileAndSTM chan tvar _) appEvent evalCmd = do
        atomically $ do
            m         <- readTVar tvar
            (r, evs)  <- either throwM pure $ evalCmd m
            storedEvs <- for evs $ \e -> do
                let s = unsafePerformIO $ toStored e
                writeTChan chan s
                pure s
            let newModel = foldl' appEvent m storedEvs
            writeTVar tvar newModel
            pure r




---- TODO: Initialize the model using the new PersistanceHandler clas!
--         Then implement ForgetfulSTM persistance, that do not persist events to disk
--         Then go ahead and make the test suite run again!
--         Then make postgres!
--createModel
--    :: PersistanceHandler pm model event
--    => pm
--    -> (model -> Stored event -> model)
--    -> model -- ^ initial model
--    -> IO (Domain pm model event)
--createModel p apply m0 = do
--    tvar <- newTVarIO m0
--    whileM_ (atomically . fmap not $ isEmptyTChan chan) . atomically $ do
--        m <- readTVar tvar
--        e <- readTChan chan
--        writeTVar tvar $ apply m e
--    pure $ Domain p apply tvar

-- This should really contain  `TChan [Stored event]` instead.
-- That would allow us to ensure that all or none of the events generated by a single
-- command is stored!
--data Persistance event = Persistance
--    { eventChan :: TChan (Stored event)
--    }
--
--persistEvent :: forall event . Persistance event -> event -> STM (Stored event)
--persistEvent (Persistance chan) e = do
--    let s = unsafePerformIO $ toStored e
--    writeTChan chan s
--    pure s
--
--
--filePersistance :: (Show e, ToJSON e, FromJSON e) => FilePath -> IO (Persistance e)
--filePersistance fp = do
--    chan <- newTChanIO
--    f    <- do
--        fileExists <- doesFileExist fp
--        if fileExists then readFileBinary fp else pure ""
--    let events = fmap eitherDecodeStrict . filter (not . BS.null) $ BS.splitWith
--            (== fromIntegral (ord '\n'))
--            f
--    traverse_ (either (throwM . EncodingError) (atomically . writeTChan chan)) events
--
--    -- Duplicate the channel so that old events are not rewritten
--    writerChan <- atomically $ dupTChan chan -- should have type `TChar [Stored event]`
--    void . async . forever $ do
--        s <- atomically $ readTChan writerChan
--        let v = encode s <> BL.singleton (fromIntegral $ ord '\n')
--        BL.appendFile fp v
--    pure $ Persistance chan
--
--noPersistance :: IO (Persistance e)
--noPersistance = Persistance <$> newTChanIO
